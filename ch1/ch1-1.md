# Ch1 构造过程抽象

## 1.1 程序设计的基本元素

### 1.1

1. 10
2. 12
3. 8
4. 3
5. 6
6. 3
7. 4
8. 19
9. #f
10. 4
11. 16
12. 6
13. 16

### 1.4

如果 b 大于 0 就执行 a + b，否则就执行 a - b，实际上等价于 a 加上 b 的绝对值。

```scheme
(define (a-plus-abs-b a b)
  (+ a (abs b))
)
```

### 1.5

如果是应用序的话，对 test 表达式求值时先要对 p 表达式求值，但是 p 表达式是递归定义的，所以会无限递归。实际上由于大部分 scheme 解释器是应用序的，所以可以直接运行这段代码来验证。

*在大部分编程语言里，对 p 求值的时候并不会替换为 p，而是报变量未定义的错误*。

如果是正则序的话：

```scheme
(test 0 (p)) ; 展开

((if (= 0 0) 0 y))
```

直接返回 0 不会报错，因为 if 的短路特性没有对 y 求值。

### 1.6

因为在调用 new-if 的时候，我们需要先对所有的子表达式全部求值，这样就会调用 sqrt-iter，然后调用 sqrt-iter 的时候又调用 new-if，所以会无限递归 new-if 和 sqrt-iter。

### 1.7

在处理非常大的数字的时候，计算 good-enough 时有可能发生差永远大于 0.001 的情况导致算法无法中止。

在处理非常小的数字的时候，如果 x 本身就比 0.001 更小，那么做差的时候很快就会中止，导致没有多跑几次迭代，结果当然会不太精确。

